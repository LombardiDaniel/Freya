/*
  Parou na 69, falta fazer o código que vê se ta frio dmais
  e se estiver, cobre e liga luz, se for horario de dia
*/

#include <DallasTemperature.h>
#include <OneWire.h>
#include <DS3231.h>
#include <Stepper.h>
#include <SD.h>
#include <SPI.h>

/*Pins*/
#define pin_temp = 2;
#define pin_moist; //analog
#define pin_light_sensor; //analog
#define pin_hose; //digital
#define pinCS; //analog
#define pin_reset; //analog
#define pin_relay; //digital

/*Variables*/
const int stepsPerRevolution = 64;
float X;
int min_moist; // valor de 0-100 (%)
int max_moint; //valor para medir qnd tenq parar
int min_temp;
bool hatch_state;

/*Objects*/
File myFile;
OneWire oneWire(pin_temp);
DallasTemperature term(&oneWire);
Stepper myStepper(stepsPerRevolution, 8,10,9,11); //pinos do stepper
Time t;
DS3231 rtc(SDA, SCL);

void setup() {

  Serial.begin(9600);

  pinMode(pin_temp, INPUT);
  pinMode(pin_moist, INPUT);
  pinMode(pin_light_sensor, INPUT);
  pinMode(pin_hose, OUTPUT);
  pinMode(pinCS, OUTPUT);
  pinMode(pin_reset, OUTPUT_PULLUP)

  SD.begin();
  rtc.begin();
  term.begin();

  new_day();

}

void loop() {

  t = rtc.getTime();
  X = t.hour + (t.min)*100/60;

  if (X == 0.0) {
    new_day();
  }

  //ve se precisa regar
  if (X == 6.0 && moist <= min_moist) { //por 10 min só (?) ou depende da mosit

    water_start();

  } else if (x >= 6.17 || moist > max_moist) {

    water_stop();

  }

  //a porta só se movimenta quando troca a hora
  if (t.min == 0) {
    if (temp() <= min_temp) {
      hatch_close();
    } else {
      hatch_open();
    }
  }

  if (hatch_state == FALSE) {
    luz();
  } else {
    luz_cut();
  }

  // Um log a cada 10 minutos
  if ((t.min)%10 != 0) {
    log_data();
  }

}

moist moist() {

  float moist;

  for (int i = 0; i < 100; i++) {
    humitty += analogRead(pin_moist);
    delay(1);
  }

  moist = (- (moist)/6.71 + 100)/50;

  if (moist > 100) {
    moist = 100;
  } else if (moist < 0) {
    moist = 0;
  }

  return moist;
}

float temp() {

  term.requestTemperatures();
  temp = term.getTempCByIndex(0);

  retrun temp;

}

long lux() {

  long luz;

  luz = analogRead(pin_light_sensor);

  return luz;
}

void water_start() {

  digitalWrite(pin_hose, HIGH);

}

void water_stop() {

  digitalWrite(pin_hose, HIGH);

}

void luz() {

  t = rtc.getTime();

  X = t.hour + (t.min)*1/60;

  f = 255.5*sin((X-6)*3.1416/12);

  digitalWrite(pin_relay,HIGH);

  if (f <= 0) {
    f = 0;
    digitalWrite(pin_relay,HIGH);
  }

  analogWrite(pin_led,f);

}

void luz_cut() {

  digitalWrite(pin_relay,HIGH)

}

void log_data() {

  t = rtc.getTime
  if (SD.begin()) {
    myFile = SD.open("Freya_data_" + rtc.getDateStr() + ".txt")
    if (myFile) {
      myFile.print(X);
      myFile.print(lux());
      myFile.print(temp());
      myFile.print(moist());
      myFile.close();
    }
  }

}

void new_day() {

  t = rtc.getTime();

  if (SD.begin()) {
    myFile = SD.open("Freya_data_" + rtc.getDateStr() + ".txt")
    if (myFile) {
      myFile.println("");
      myFile.println("TIME,LIGHT,SOIL_TEMPERATURE,SOIL_MOISTURE");
      myFile.close();
    }
  }

}

void hatch_open() {

  hatch_state = TRUE;
}

void hatch_close() {
  hatch_state = FALSE;
}
